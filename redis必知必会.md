- [1.为啥单线程redis那么快？](#1为啥单线程redis那么快)
  - [怎么理解单线程](#怎么理解单线程)
  - [redis为什么用单线程？](#redis为什么用单线程)
  - [redis单线程怎么用？](#redis单线程怎么用)
  - [redis是内存数据库并有高效数据结构](#redis是内存数据库并有高效数据结构)
- [2.redis中高效的数据结构？](#2redis中高效的数据结构)
  - [谈谈Hash](#谈谈hash)
  - [底层数据结构方面：可以谈压缩列表、跳表](#底层数据结构方面可以谈压缩列表跳表)
  - [几种底层数据结构的时间复杂度](#几种底层数据结构的时间复杂度)
  - [String 数据类型和具体实现](#string-数据类型和具体实现)
- [3.持久化](#3持久化)
  - [什么是redis持久化？](#什么是redis持久化)
  - [谈谈AOF](#谈谈aof)
    - [AOF如何实现？](#aof如何实现)
    - [AOF写数据的三种策略](#aof写数据的三种策略)
    - [日志文件太大了怎么办？谈谈AOF重写机制？](#日志文件太大了怎么办谈谈aof重写机制)
    - [如何配置AOF重写？](#如何配置aof重写)
    - [AOF 重写仍然很耗时，会阻塞吗?重写流程是怎样的？](#aof-重写仍然很耗时会阻塞吗重写流程是怎样的)
    - [如何配置开启AOF？](#如何配置开启aof)
    - [AOF日志的优缺点是什么？](#aof日志的优缺点是什么)
  - [谈谈RDB](#谈谈rdb)
    - [RDB怎么实现的？](#rdb怎么实现的)
    - [RDB的优缺点](#rdb的优缺点)
    - [快照时数据能修改吗？](#快照时数据能修改吗)
    - [可以每秒做一次快照吗？](#可以每秒做一次快照吗)
  - [AOF和RDB比较](#aof和rdb比较)
  - [如何选择合适的持久化方式？](#如何选择合适的持久化方式)
  - [Redis持久化数据和缓存怎么做扩容？](#redis持久化数据和缓存怎么做扩容)
- [4.Redis过期数据删除策略](#4redis过期数据删除策略)
  - [什么是过期数据？](#什么是过期数据)
  - [时效性数据的存储结构](#时效性数据的存储结构)
  - [数据删除策略有哪些？](#数据删除策略有哪些)
- [5.Redis内存满了怎么办？怎么优化？](#5redis内存满了怎么办怎么优化)
  - [当新数据进入redis时，如果内存不足并且没有key过期怎么办？逐出算法](#当新数据进入redis时如果内存不足并且没有key过期怎么办逐出算法)
  - [谈谈缓存数据的淘汰机制（逐出算法）？](#谈谈缓存数据的淘汰机制逐出算法)
  - [谈谈LRU、LFU？](#谈谈lrulfu)
- [6.谈谈对Redis事务的理解？](#6谈谈对redis事务的理解)
  - [先说说什么是事务？](#先说说什么是事务)
  - [说说什么是redis事务](#说说什么是redis事务)
  - [redis怎样实现事务?](#redis怎样实现事务)
  - [Redis 通过 MULTI、EXEC、DISCARD 和 WATCH 四个命令来支持事务机制](#redis-通过-multiexecdiscard-和-watch-四个命令来支持事务机制)
  - [那Redis事务还有没有其他实现？](#那redis事务还有没有其他实现)
  - [Redis能否满足事务的ACID属性？(重要)](#redis能否满足事务的acid属性重要)
- [7.Redis锁(分布式锁)](#7redis锁分布式锁)
  - [什么是分布式锁？](#什么是分布式锁)
  - [Redis分布式锁方案一：SETNX + EXPIRE](#redis分布式锁方案一setnx--expire)
  - [Redis分布式锁方案二：SETNX + value值是(系统时间+过期时间)](#redis分布式锁方案二setnx--value值是系统时间过期时间)
  - [Redis分布式锁方案三：使用Lua脚本(包含SETNX + EXPIRE两条指令)](#redis分布式锁方案三使用lua脚本包含setnx--expire两条指令)
  - [Redis分布式锁方案四：SET的扩展命令（SET EX PX NX）TODO](#redis分布式锁方案四set的扩展命令set-ex-px-nxtodo)
  - [Redis分布式锁方案五：SET EX PX NX + 校验唯一随机值,再删除 TODO](#redis分布式锁方案五set-ex-px-nx--校验唯一随机值再删除-todo)
  - [Redis分布式锁方案六：Redisson框架 TODO](#redis分布式锁方案六redisson框架-todo)
  - [Redis分布式锁方案三：使用Lua脚本(包含SETNX + EXPIRE两条指令)TODO](#redis分布式锁方案三使用lua脚本包含setnx--expire两条指令todo)
- [8.Redis 主从复制](#8redis-主从复制)
  - [redis 主从复制是啥？](#redis-主从复制是啥)
### 1.为啥单线程redis那么快？
* 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速；
* 数据结构简单，对数据操作也简单；
* 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
* 使用多路 I/O 复用模型，非阻塞 IO。

#### 怎么理解单线程
* 首先咱得知道Redis是单线程。
* 主要是指 Redis的**网络 IO** 和**键值对读写**是**由一个线程来完成**，这也是 Redis 对外提供键值存储服务的主要流程。
* 但 Redis 的其他功能，比如持久化等其实是由额外线程执行的。

#### redis为什么用单线程？
>主要是为了避免多线程的开销问题。
* 避免多线程编程面临的共享资源的并发访问控制问题;
* 避免锁的控制以及死锁问题导致的性能开销;
* 为了系统代码的易调试性和可维护性。

#### redis单线程怎么用？
>Redis 是采用了**多路复用机制**，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。
* redis采用非阻塞模式：阻塞模式下三个网络IO可能的阻塞点，**监听请求（bind/listen），建立连接（accept），读取请求（recv）**会导致 Redis 整个线程阻塞，无法处理其他客户端请求，效率很低。所以redis采用非阻塞模式，当 Redis 调用 accept() 但一直未有连接请求到达时，Redis 线程可以返回处理其他操作，而不用一直等待。
* **基于多路复用的高性能 I/O 模型，就是一个线程处理多个 IO 流。**简单来说，在 Redis 单线程的情况下，允许内核中存在多个监听套接字和已连接套接字。内核监听套接字上的请求。一旦请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。请求到达时能通知到 Redis 线程，select/epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数。
* 再说回调机制，select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。事件会被放进一个队列，Redis 单线程对该事件队列不断进行处理调用相应的处理函数。这样一来，Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费，提升 Redis 的响应性能。

#### redis是内存数据库并有高效数据结构
> Redis 的大部分操作在内存上完成，再加上它采用了**高效的数据结构**，例如哈希表和跳表，这是它实现高性能的一个重要原因。

### 2.redis中高效的数据结构？
> redis中有五种**数据类型**

* String（字符串）可以做简单的键值对缓存；
* List（列表）可以存储一些列表型的数据结构；
* Hash（哈希）可以存结构化的数据，比如一个对象；
* Set（集合）可以做交集、并集、差集的操作，比如交集，可以把两个人的粉丝列表整一个交集；
* Sorted Set（有序集合）去重但可以排序，如获取排名前几名的用户。

![redis数据类型和底层数据结构的对应关系](./img/屏幕截图%202022-02-25%20135849.png)

String 类型的底层实现只有一种数据结构，简单动态字符串。
Hash是当数据量较小时用压缩列表实现，较大时用哈希表实现并且不可逆就行了。

#### 谈谈Hash
首先一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。

![全局哈希表](./img/屏幕截图%202022-02-25%20140225.png)

优点：O(1)的时间复杂度可以空手找到键值对
缺点：哈希表的冲突问题和rehash可能带来的操作冲突

**如何解决？**
* 拉链法。链式哈希也很容易理解，就是指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。
* rehash，过程分为三步：
  1. 给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；
  2. 把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；
  3. 释放哈希表 1 的空间。
* **渐进式 rehash。**方案二第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。
  * 简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries(即一个哈希桶上的所有entry) 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问。

#### 底层数据结构方面：可以谈压缩列表、跳表
首先 redis集合类型的底层数据结构主要有 5 种：**整数数组、双向链表、哈希表、压缩列表和跳表**

* 压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。

![压缩列表的查找](./img/屏幕截图%202022-02-25%20141707.png)

* 跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位

![跳表的查找](./img/屏幕截图%202022-02-25%20141917.png)

#### 几种底层数据结构的时间复杂度
![时间复杂度](./img/屏幕截图%202022-02-25%20142154.png)

#### String 数据类型和具体实现

### 3.持久化
#### 什么是redis持久化？
持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。

Redis 的持久化主要有两大机制，即 AOF（Append Only File）日志和 RDB 快照。

* AOF将数据的操作过程进行保存，**日志形式，存储操作过程**，存储格式复杂，**关注点在数据的操作过程**
* RDB将当前数据状态进行保存，**快照形式，存储数据结果**，存储格式简单，**关注点在数据**

#### 谈谈AOF
##### AOF如何实现？
* AOF(append only file)持久化：**以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令达到恢复数据的目的**。 与RDB相比可以简单描述为 改记录数据为记录数据产生的过程
* AOF的主要作用是 解决了数据持久化的时效性，目前已经是Redis持久化的主流方式。
* 优先使用AOF

##### AOF写数据的三种策略
* Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；
* Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；
* No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。

##### 日志文件太大了怎么办？谈谈AOF重写机制？
* AOF重写机制：对过大的AOF文件进行重写，以此来压缩AOF文件的大小。
* 实现：检查当前键值数据库中的键值对， 记录键值对的最终状态，从而实现对某个键值对重复操作后产生的多条操作记录压缩成一条的效果。进而实现压缩AOF文件的大小。

##### 如何配置AOF重写？
**手动重写方式**
* 手动重写：`bgrewriteaof`，后台执行，并不是立马执行
**自动重写方式**
* 自动重写触发条件设置，比size大就自动重写，比自动重写百分比大就重写
```properties
auto-aof-rewrite-min-size size #比size大就自动重写
auto-aof-rewrite-percentage percentage #比自动重写百分比大就重写
```
* 自动重写触发比对参数（运行指令info Persistence获取具体信息），aof_current_size 用于和size对比
```properties
aof_current_size 
aof_base_size
```
* 自动重写触发条件，满足一个就进行自动重写
![触发条件](./img/屏幕截图%202022-02-25%20143931.png)

##### AOF 重写仍然很耗时，会阻塞吗?重写流程是怎样的？
和 AOF 日志由主线程写回不同，重写过程是由后台子进程 `bgrewriteaof` 来完成的，这也是为了避免阻塞主线程，导致数据库性能下降。

**重写过程**
每次执行重写时，主线程 fork 出后台的 `bgrewriteaof` 子进程。此时，fork 会把主线程的内存拷贝一份给 `bgrewriteaof` 子进程，这里面就包含了数据库的最新数据。然后，`bgrewriteaof` 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。

**数据不一致问题？**
> 子进程在进行AOF重写期间，服务器进程还要继续处理命令请求，而新的命令可能对现有的数据进行修改，这会让当前数据库的数据和重写后的AOF文件中的数据不一致。

* 为了解决这种数据不一致的问题，Redis增加了一个AOF重写缓存，这个缓存在fork出子进程之后开始启用，Redis服务器 主进程 在执行完写命令之后，会同时将这个写命令追加到 `AOF缓冲区` 和 `AOF重写缓冲区`
* 即子进程在执行AOF重写时，主进程需要执行以下三个工作：
  * 执行client发来的命令请求；
  * 将写命令追加到现有的AOF文件中；
  * 将写命令追加到AOF重写缓存中。
* 完成AOF重写之后：当子进程完成对AOF文件重写之后，它会向父进程发送一个完成信号，父进程接到该完成信号之后，会调用一个信号处理函数，该函数完成以下工作：
  * 将AOF重写缓存中的内容全部写入到新的AOF文件中；这个时候新的AOF文件所保存的数据库状态和服务器当前的数据库状态一致；
  * 对新的AOF文件进行改名，原子的覆盖原有的AOF文件；完成新旧两个AOF文件的替换。
* 当这个信号处理函数执行完毕之后，主进程就可以继续像往常一样接收命令请求了。

在整个AOF后台重写过程中，只有最后的 “主进程写入命令到AOF缓存”和“对新的AOF文件进行改名，覆盖原有的AOF文件。” 这两个步骤（信号处理函数执行期间）会造成主进程阻塞，在其他时候，AOF后台重写都不会对主进程造成阻塞，这将AOF重写对性能造成的影响降到最低。

##### 如何配置开启AOF？
* 配置：`appendonly yes|no` 作用：是否开启AOF持久化功能，默认为不开启状态
* 配置：`appendfsync always|everysec|no` 作用：配置AOF写数据策略
* 配置：`appendfilename filename` 作用：AOF持久化文件名，默认文件名未`appendonly.aof`，建议配置为`appendonly-端口号.aof`
* 配置：`dir` 作用：AOF持久化文件保存路径，与RDB持久化文件保持一致即可

##### AOF日志的优缺点是什么？
**优点**
1. 数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。
2. 通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。
3. AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）

**缺点**
1. AOF 文件比 RDB 文件大，且恢复速度慢。
2. 数据集大的时候，比 rdb 启动效率低。

#### 谈谈RDB
##### RDB怎么实现的？
和 AOF 相比，RDB 记录的是某一时刻的数据，并不是操作，所以，在做数据恢复时，我们可以直接把 RDB 文件读入内存，很快地完成恢复。

Redis 的数据都在内存中，为了提供所有数据的可靠性保证，它执行的是全量快照，也就是说，把内存中的所有数据都记录到磁盘中

通过`bgsave`命令在后台执行全量快照

##### RDB的优缺点
**优点**
1. RDB是一个紧凑压缩的二进制文件，存储效率较高
2. RDB内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景
3. RDB恢复数据的速度要比AOF快很多
4. 应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。

**缺点**
* 数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)

##### 快照时数据能修改吗？
可以，Redis 就会借助操作系统提供的 **写时复制技术** ，在执行快照的同时，正常处理写操作。如果主线程要修改一块数据（例如图中的键值对 C），那么， **这块数据就会被复制一份** ，生成该数据的副本（键值对 C’）。然后，**主线程在这个数据副本上进行修改**。同时，bgsave 子进程可以继续把原来的数据（键值对 C）写入 RDB 文件。

##### 可以每秒做一次快照吗？
不行。如果频繁地执行全量快照，也会带来两方面的开销：
* 一方面，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。
* 另一方面，`bgsave` 子进程需要通过 fork 操作从主线程创建出来。子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 `bgsave` 子进程，这就会频繁阻塞主线程了（所以，在 Redis 中如果有一个 `bgsave` 在运行，就不会再启动第二个 `bgsave` 子进程）。

**混合使用 AOF 日志和内存快照**
内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。既能享受到 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令的简单优势

![混合使用 AOF 日志和内存快照](./img/屏幕截图%202022-02-25%20150624.png)

#### AOF和RDB比较
* AOF文件比RDB更新频率高，优先使用AOF还原数据。
* AOF比RDB更安全也更大
* RDB性能比AOF好
* 如果两个都配了优先加载AOF

#### 如何选择合适的持久化方式？
* 如果想达到高的数据安全性，你应该同时使用两种持久化功能。在这种情况下，当 Redis 重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。
* 如果你非常关心你的性能， 同时可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化。
* 有很多用户都只使用AOF持久化everysec，但并不推荐这种方式，因为定时生成RDB快照非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快。
* 如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。

#### Redis持久化数据和缓存怎么做扩容？

### 4.Redis过期数据删除策略
#### 什么是过期数据？
Redis中有个设置时间过期的功能，即对存储在redis数据库中的值可以设置一个过期时间。

`set key`的时候，都可以给一个`expire time`，就是过期时间，通过过期时间就可以指定这个`key`可以存活的时间。

Redis是一种内存级数据库，所有数据均存放在内存中，内存中的数据可以通过TTL指令获取其状态

* XX ：具有时效性的数据
* 1 ：永久有效的数据
* 2 ：已经过期的数据 或 被删除的数据 或 未定义的数据

#### 时效性数据的存储结构
* 当给name设置值itheima，它会有一个十六进制的存储地址
* redis中会开放一块空间（expires），存放的就是 存储地址:过期时间
* 删除策略就是操作expires空间

![expire](./img/屏幕截图%202022-02-25%20151414.png)

#### 数据删除策略有哪些？
**定时删除和惰性删除**
* 定时删除：创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作。
  * 优点：节约内存，到时就删除，快速释放掉不必要的内存占用
  * 缺点：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量
  * 总结：用处理器性能换取存储空间（拿时间换空间）
* 惰性删除：数据到达过期时间，不做处理。等下次访问该数据时，如果未过期，返回数据；发现已过期，删除，返回不存在。内部执行 `expireIfNeeded()` 函数，检查数据是否过期，所有的get操作都与它绑定
  * 优点：节约CPU性能，发现必须删除的时候才删除
  * 缺点：内存压力很大，出现长期占用内存的数据
  * 总结：用存储空间换取处理器性能（拿空间换时间）


**定期删除执行流程：**
>redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢?假如redis存了几十万个key，每隔100ms就遍历所有的设置过期时间的key的话，就会给CPU带来很大的负载。
* 每个库都有一个expires
  
![redis存储空间](./img/屏幕截图%202022-02-25%20152209.png)

* Redis启动服务器初始化时，读取配置`server.hz`的值，默认为10(频率为10,即周期为100ms)
* 每秒钟执行`server.hz`次，`serverCron()` ==> `databasesCron()` == > `activeExpireCycle()`
  * `serverCron()` ：对服务器进行定时轮询
  * `databasesCron()`：对每个库进行轮询（轮询expires）
  * `activeExpireCycle()`：对每个`expires[i]`逐一进行检测，每次执行250ms/`server.hz`
* 对某个expires[*]检测时，随机挑选W个key检测
  * 如果key超时，删除key
  * 如果一轮中删除的key的数量>W * 25%，循环该过程
  * 如果一轮中删除的key的数量≤W * 25%，检查下一个expires[i]，0-15循环（redis默认有16个库）
  * 找多少个key可以自己设定： W取值=`ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP`属性值
* 参数`current_db`用于记录`activeExpireCycle()` 进入哪个`expires[i]` 执行，如果`activeExpireCycle()`执行时间到期，下次从`current_db`继续向下执行
### 5.Redis内存满了怎么办？怎么优化？
#### 当新数据进入redis时，如果内存不足并且没有key过期怎么办？逐出算法
* Redis使用内存存储数据，在执行每一个命令前，会调用 `freeMemoryIfNeeded()` 检测内存是否充足。如果内存不满足新加入数据的最低存储要求，redis要 临时删除 一些数据为当前指令清理存储空间。**清理数据的策略称为逐出算法**。
* 注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，**如果不成功则反复执行**。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。
  >(error)OOM command not allowed when used memory>'maxmemory'
#### 谈谈缓存数据的淘汰机制（逐出算法）？
* 不进行数据淘汰的策略，只有 `no-eviction` 这一种，会引发错误`OOM(Out Of Memory)`，内存泄漏
* 会进行淘汰的 7 种策略，我们可以再进一步根据淘汰候选数据集的范围把它们分成两类:
  * 在设置了过期时间的数据中进行淘汰，包括 volatile-random、volatile-ttl、volatile-lru、volatile-lfu四种
    * volatile-lru：使用 LRU 算法筛选设置了过期时间的键值对，**即挑选最近最少使用的数据淘汰（laest recently used，推荐设置）**，也就是首先淘汰最长时间未被使用的数据!
    * volatile-lfu：使用 LFU 算法选择设置了过期时间的键值对，**即挑选最近最不常用的数据淘汰（laest frequently used）**，也就是淘汰一定时期内被访问次数最少的数据!
    * volatile-ttl：**挑选将要过期的数据淘汰**（按照过期时间淘汰）
    * volatile-random：在设置了过期时间的键值对中，进行随机删除。
  * 在所有数据范围内进行淘汰，包括 allkeys-lru、allkeys-random、allkeys-lfu三种。
    * allkeys-lru：挑选最近最少使用的数据淘汰
    * allkeys-lfu：挑选最近最不常用的数据淘汰
    * allkeys-random：从所有键值对中随机选择并删除数据；
#### 谈谈LRU、LFU？
### 6.谈谈对Redis事务的理解？
#### 先说说什么是事务？
>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。

>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。

满足以下要求(ACID)：
* 原子性(atomicity)：原子性的要求很明确，就是一个事务中的多个操作必须都完成，或者都不完成。
* 一致性(consistency)：就是指数据库中的数据在事务执行前后是一致的。
* 隔离性(isolation)：它要求数据库在执行一个事务时，其它操作无法存取到正在执行事务访问的数据。
* 持久性(durability)：数据库执行事务后，数据的修改要被持久化保存下来。当数据库重启后，数据的值需要是被修改后的值。

#### 说说什么是redis事务
redis事务就是一个**命令执行的队列**，将一系列预定义命令包装成一个整体（一个队列）。当执行时，一次性按照添加顺序依次执行，中间不会被打断或者干扰。

**一个队列中，一次性、顺序性、排他性的执行一系列命令**

#### redis怎样实现事务?
三个阶段：
1. 事务开始 MULTI
2. 命令入队，Redis 实例只是把这些命令暂存到一个命令队列中，并不会立即执行。
3. 事务执行 EXEC，执行命令队列中的所有命令。

* 事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排队。

#### Redis 通过 MULTI、EXEC、DISCARD 和 WATCH 四个命令来支持事务机制
![redis事务的四个命令](./img/屏幕截图%202022-02-25%20212019.png)

* WATCH命令可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行。监控一直持续到EXEC命令（事务中的命令是在EXEC之后才执行的，所以在MULTI命令后可以修改WATCH监控的键值）
* discard在使用中，如果multi开启事务，命令入队，直接discard的话，所有的命令都会回滚。

#### 那Redis事务还有没有其他实现？
* 基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完。
* 基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐

#### Redis能否满足事务的ACID属性？(重要)
>ACID，是指数据库管理系统（DBMS）在写入或更新资料的过程中，为保证事务（transaction）是正确可靠的，所必须具备的四个特性：原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）。

1. atomicity: 
   
   * 命令入队时就报错，会放弃事务执行，保证原子性；
   * 命令入队时没报错，实际执行时报错，不保证原子性；
   * EXEC 命令执行时实例故障，如果开启了 AOF 日志，可以保证原子性。

  第一种情况是，在执行 EXEC 命令前，客户端发送的操作命令本身就有错误，在命令入队时就被 Redis 实例判断出来了。提交时Redis会拒绝执行。能保证。

  第二种情况。事务操作入队时，命令有问题，但 Redis 实例没有检查出错误。但是，在执行完 EXEC 命令以后，Redis 实际执行这些事务操作时，就会报错。但还是会把正确的命令执行完。原子性就无法得到保证了。（Redis 中并没有提供回滚机制。）

  第三种情况：在执行事务的 EXEC 命令时，Redis 实例发生了故障，导致事务执行失败。如果开启了 AOF 日志，那么只会有部分的事务操作被记录到 AOF 日志中。使用 `redis-check-aof` 工具检查 AOF 日志文件，把未完成的事务操作从 AOF 文件中去除，从而保证了原子性。 没开AOF就不保证。

  ---
2. consistency
   
  情况一：命令入队就报错，不执行，可以保证一致性
  
  情况二：命令入队时没报错，实际执行时报错，正确的命令执行，错误的命令不执行，保证。

  情况三：EXEC 命令执行时实例发生故障，没开RDB和AOF数据为空保证，只开RDB不会在事务时执行快照保证，只开AOF是可以删的保证。

  ---
3. isolation

  两种情况：

  情况一：并发操作在 EXEC 命令前执行，此时，隔离性的保证要使用 WATCH 机制来实现，否则隔离性无法保证；
  
  * WATCH 机制的作用是，在事务执行前，监控一个或多个键的值变化情况，当事务调用 EXEC 命令执行时，WATCH 机制会先检查监控的键是否被其它客户端修改了。如果修改了，就放弃事务执行，避免事务的隔离性被破坏。然后，客户端可以再次执行事务，此时，如果没有并发修改事务数据的操作了，事务就能正常执行，隔离性也得到了保证。

  情况二：并发操作在 EXEC 命令后执行，此时，隔离性可以保证。

  * 因为 Redis 是用单线程执行命令，而且，EXEC 命令执行后，Redis 会保证先把命令队列中的所有命令执行完。所以，在这种情况下，并发操作不会破坏事务的隔离性

   ---
4. durability

  * 如果 Redis 没有使用 RDB 或 AOF，那么事务的持久化属性肯定得不到保证。
  * 如果 Redis 使用了 RDB 模式，那么，在一个事务执行后，而下一次的 RDB 快照还未执行前，如果发生了实例宕机，这种情况下，事务修改的数据也是不能保证持久化的。
  * 如果 Redis 采用了 AOF 模式，因为 AOF 模式的三种配置选项 no、everysec 和 always 都会存在数据丢失的情况，所以，事务的持久性属性也还是得不到保证。

  ---
**总结：**
Redis 的事务机制可以保证一致性和隔离性，但是无法保证持久性。不过，因为 Redis 本身是内存数据库，持久性并不是一个必须的属性，我们更加关注的还是原子性、一致性和隔离性这三个属性。原子性的情况比较复杂，只有当事务中使用的命令语法有误时，原子性得不到保证，在其它情况下，事务都可以原子性执行。

**建议：** 严格按照 Redis 的命令规范进行程序开发，并且通过 code review 确保命令的正确性。

### 7.Redis锁(分布式锁)
#### 什么是分布式锁？

分布式锁其实就是，控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。

![分布式锁](./img/屏幕截图%202022-02-25%20214424.png)

#### Redis分布式锁方案一：SETNX + EXPIRE
即先用setnx来抢锁，如果抢到之后，再用expire给锁设置一个过期时间，防止锁忘记了释放。

SETNX 是SET IF NOT EXISTS的简写。日常命令格式是SETNX key value。如果 key不存在，则SETNX成功返回1，如果这个key已经存在了，则返回0。
```java
if（jedis.setnx(key_resource_id,lock_value) == 1）{ //加锁
    expire（key_resource_id，100）; //设置过期时间
    try {
        do something  //业务请求
    }catch(){
  }
  finally {
       jedis.del(key_resource_id); //释放锁
    }
}
```
但是这个方案中，setnx和expire两个命令分开了， 「不是原子操作」 。如果执行完setnx加锁，正要执行expire设置过期时间时，进程crash或者要重启维护了，那么这个锁就别的线程就永远获取不到了。

#### Redis分布式锁方案二：SETNX + value值是(系统时间+过期时间)
```java
long expires = System.currentTimeMillis() + expireTime; //系统时间+设置的过期时间
String expiresStr = String.valueOf(expires);

// 如果当前锁不存在，返回加锁成功
if (jedis.setnx(key_resource_id, expiresStr) == 1) {
        return true;
} 
// 如果锁已经存在，获取锁的过期时间
String currentValueStr = jedis.get(key_resource_id);

// 如果获取到的过期时间，小于系统当前时间，表示已经过期
if (currentValueStr != null && Long.parseLong(currentValueStr) < System.currentTimeMillis()) {

     // 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间
     // 将给定 key 的值设为 value ，并返回 key 的旧值(old value)
    String oldValueStr = jedis.getSet(key_resource_id, expiresStr);
    
    if (oldValueStr != null && oldValueStr.equals(currentValueStr)) {
         // 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才可以加锁
         return true;
    }
}
        
//其他情况，均返回加锁失败
return false;
}
```
这个方案的优点是，巧妙移除expire单独设置过期时间的操作，把 过期时间放到setnx的value值 里面来。解决了方案一发生异常，锁得不到释放的问题。但是这个方案还有别的缺点：
* 过期时间是客户端自己生成的（System.currentTimeMillis()是当前系统的时间），必须要求分布式环境下，每个客户端的时间必须同步 。
* 如果锁过期的时候，并发多个客户端同时请求过来，都执行jedis.getSet()， 最终只能有一个客户端加锁成功，但是该客户端锁的过期时间，可能被别的客户端覆盖 。
* 该锁 没有保存持有者的唯一标识 ，可能被别的客户端 释放/解锁 。
  
#### Redis分布式锁方案三：使用Lua脚本(包含SETNX + EXPIRE两条指令)
实际上，我们还可以使用Lua脚本来保证原子性（包含setnx和expire两条指令），lua脚本如下：
```lua
if redis.call('setnx',KEYS[1],ARGV[1]) == 1 then
   redis.call('expire',KEYS[1],ARGV[2])
else
   return 0
end;
```
加锁代码如下：
```java
String lua_scripts = "if redis.call('setnx',KEYS[1],ARGV[1]) == 1 then" +
            " redis.call('expire',KEYS[1],ARGV[2]) return 1 else return 0 end";   
Object result = jedis.eval(lua_scripts, Collections.singletonList(key_resource_id), Collections.singletonList(values));
//判断是否成功
return result.equals(1L);
```
#### Redis分布式锁方案四：SET的扩展命令（SET EX PX NX）TODO
#### Redis分布式锁方案五：SET EX PX NX + 校验唯一随机值,再删除 TODO
#### Redis分布式锁方案六：Redisson框架 TODO
#### Redis分布式锁方案三：使用Lua脚本(包含SETNX + EXPIRE两条指令)TODO

### 8.Redis 主从复制
#### redis 主从复制是啥？
**主从复制：** 指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader），后者称为从节点（Slave/Follower）。

* 数据的复制是单向的！只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。
* Redis的主从复制是异步复制，异步分为两个方面：
  * 一个是master服务器在将数据同步到slave时是异步的，因此master服务器在这里仍然可以接收其他请求
  * 一个是slave在接收同步数据也是异步的。